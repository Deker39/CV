# -*- coding: utf8 -*-

# импортирование необходимых библиотек
import numpy as np
import cv2
import imutils
import matplotlib.pyplot as plt

# параметр для сканируемого изображения
args_image = '1.jpg'

# прочитать изображение
image = cv2.imread(args_image)
orig = image.copy()

# конвертация изображения в градации серого. Это уберёт цветовой шум
grayImage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# размытие картинки, чтобы убрать высокочастотный шум
# это помогает определить контур в сером изображении
grayImageBlur = cv2.GaussianBlur(grayImage,(3,3),0)

# Set the lower and upper threshold
med_val = np.median(image)
lower = int(max(0, .7*med_val))
upper = int(min(255, 1.3*med_val))

# теперь производим определение границы по методу Canny
edgedImage = cv2.Canny(grayImageBlur, lower ,upper+100 )

# показать серое изображение с определенными границами
# cv2.imshow("gray", grayImage)
# cv2.imshow("grayBlur", grayImageBlur)
cv2.imshow("Edge Detected Image", edgedImage)


# найти контуры на обрезанном изображении, рационально организовать область
# оставить только большие варианты
allContours = cv2.findContours(edgedImage.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
allContours = imutils.grab_contours(allContours)

# сортировка контуров области по уменьшению и сохранение топ-1
allContours = sorted(allContours, key=cv2.contourArea, reverse=True)[:1]

# aппроксимация контура
perimeter = cv2.arcLength(allContours[0],True)
ROIdimensions = cv2.approxPolyDP(allContours[0], perimeter*0.02, True)

# показать контуры на изображении
cv2.drawContours(image, [ROIdimensions], -1, (0,255,0), 4)
cv2.imshow('Contour Outline', image)


# изменение массива координат
ROIdimensions = ROIdimensions.reshape(len(ROIdimensions),2)


# список удержания координат ROI
rect = np.zeros((4,2), dtype='float32')

# наименьшая сумма будет у верхнего левого угла,
# наибольшая — у нижнего правого угла
s = np.sum(ROIdimensions, axis=1)
rect[0] = ROIdimensions[np.argmin(s)]
rect[2] = ROIdimensions[np.argmax(s)]

# верх-право будет с минимальной разницей
# низ-лево будет иметь максимальную разницу
diff = np.diff(ROIdimensions, axis=1)
rect[1] = ROIdimensions[np.argmin(diff)]
rect[3] = ROIdimensions[np.argmax(diff)]

# верх-лево, верх-право, низ-право, низ-лево
(tl, tr, br, bl) = rect

# вычислить ширину ROI
widthA = np.sqrt((tl[0] - tr[0])**2 + (tl[1] - tr[1])**2 )
widthB = np.sqrt((bl[0] - br[0])**2 + (bl[1] - br[1])**2 )
maxWidth = max(int(widthA), int(widthB))

# вычислить высоту ROI
heightA = np.sqrt((tl[0] - bl[0])**2 + (tl[1] - bl[1])**2 )
heightB = np.sqrt((tr[0] - br[0])**2 + (tr[1] - br[1])**2 )
maxHeight = max(int(heightA), int(heightB))

# набор итоговых точек для обзора всего документа
# размер нового изображения
dst = np.array([
    [0,0],
    [maxWidth-1, 0],
    [maxWidth-1, maxHeight-1],
    [0, maxHeight-1]], dtype="float32")

# вычислить матрицу перспективного преобразования и применить её
transformMatrix = cv2.getPerspectiveTransform(rect, dst)

# преобразовать ROI
scan = cv2.warpPerspective(orig, transformMatrix, (maxWidth, maxHeight))

# давайте посмотрим на свёрнутый документ
# cv2.imshow("Scaned",scan)

# конвертация в серый
scanGray = cv2.cvtColor(scan, cv2.COLOR_BGR2GRAY)

# показать финальное серое изображение
cv2.imshow("scanGray", scanGray)

isWritten = cv2.imwrite('123.jpg', scanGray)
# ------------------------------

# конвертация в черно-белое с высоким контрастом для документов
from skimage.filters import threshold_local
# увеличить контраст в случае с документом
T = threshold_local(scanGray, 9, offset=8, method="gaussian")
scanBW = (scanGray > T).astype('uint8') * 255

# показать финальное изображение с высоким контрастом
cv2.imshow("scanBW", scanBW)
cv2.waitKey(0)
cv2.destroyAllWindows()

import img2pdf

a4_page_size = [img2pdf.in_to_pt(8.3), img2pdf.in_to_pt(11.7)]
layout_function_a4 = img2pdf.get_layout_fun(a4_page_size)

a5_page_size = [img2pdf.in_to_pt(5.9), img2pdf.in_to_pt(8.3)]
layout_function_a5 = img2pdf.get_layout_fun(a5_page_size)

pdf = img2pdf.convert('123.jpg', layout_fun=layout_function_a4)
with open('A4_act.pdf', 'wb') as f:
     f.write(pdf)

